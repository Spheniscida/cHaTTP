# The message-broker/persistence-layer protocol

The message broker uses the persistence layer to obtain information
on users and other (remote) message brokers. Another purpose is saving messages
for users which are currently off-line.

This protocol is stateless and will probably use UNIX datagram sockets. The path of
the socket is specified in an environment variable.

This specification uses the keywords indicated by RFC 2119.

This protocol works like the other one (the one between persistence layer and message broker):

    <sequence number> <REQUEST TYPE> [additional information]

    <sequence number> <RESPONSE TYPE> {OK [additional information]|FAIL [additional information]}

The sequence number (`<seqn>`) *n* SHALL be smaller than 2^64 and SHALL be greater than 0. 0 is reserved (for parsing failures).
The sequence number MUST be a base-10 number written in ASCII.

The sequence number SHOULD be unique. If one sequence number is used twice, participating applications may show
undefined behavior. Applications SHOULD be safe against a non-unique sequence number if that number is used
twice with an interval of, say, 30 minutes or more, between the two uses.

Two message referring to the same operation MUST bear the same sequence number.

The response type MUST be uppercase and SHOULD give a hint on the operation (e.g. register user: UREG).

The keywords `OK` and `FAIL` may be followed by arbitrary information having the same format for all messages with
a given response type.

## Configuration

The persistence layer is configured using the following environment variables:

* `CHATTP_PERSISTENCE_LAYER_FAMILY` - ("UNIX"/"INET") How to connect to the persistence layer.
* `CHATTP_PERSISTENCE_LAYER_ADDR` - The hostname / socket path of the persistence layer daemon.
* `CHATTP_PERSISTENCE_LAYER_PORT` - The port of the persistence layer daemon, empty if using UNIX domain.
* `CHATTP_REDIS_FAMILY` - ("UNIX"/"INET") How to connect to redis.
* `CHATTP_REDIS_ADDR` - Redis' hostname / socket path.
* `CHATTP_REDIS_PORT` - Redis' port,  mpty if using UNIX domain.

## Command types

The fields of the commands MUST be delimited by newlines (LF). The specification below uses
spaces solely for better readability.

The answer MUST contain a status stating if an operation failed or succeeded. This status MUST be indicated
by the keywords `OK` and `FAIL`.

The command tokens are not fixed yet and may change in future, as well as the actual message format.

### Register user

    <sequence number> UREG <user name> <password>
    [answer:]
    <sequence number> UREGD {OK|FAIL}

Register a new user with the specified password. This operation MUST fail if there's already a user registered
with this name. A protocol message type for changing the password may come in the near future.

### Check submitted password

    <sequence number> CHKPASS <user name> <submitted password>
    [answer:]
    <sequence number> CHKDPASS {OK|FAIL}

Check if the submitted password is correct. This command is used when logging in a already registered user. This command
MUST fail if the password is not correct or the user doesn't exist.

### Mark user as on-line

    <sequence number> LOGIN <user name> <message broker name> <channel id>
    [answer:]
    <sequence number> LGDIN {OK|FAIL}

Log the specified user in and specify which message broker has to be used to send messages to that user. This SHOULD
be a valid FQDN. It also MAY be an IP address.

### Mark user as off-line

    <sequence number> LOGOUT <user name>
    [answer:]
    <sequence number> LGDOUT OK

This command MUST not fail. It tells the persistence layer that it shall mark the user as offline, so following ULKUP
queries will return OFFLINE. If a user is already marked as offline, do nothing.

### Look up the location of a user's session

    <sequence number> ULKUP <user name>
    [answer:]
    <sequence number> ULKDUP {OK <message broker name> <channel id>|OFFLINE|FAIL}

Look up where a certain user may be reached; if cHaTTP runs on a cluster, two communicating users may be logged in
on two different web servers and therefore message brokers. The information is stored in a central Redis database.

In case of OFFLINE, the message broker will save the received message with the following message type.

### Save a message

    <sequence number> MSGSV <user name> <message text/information>
    [answer:]
    <sequence number> MSGSVD {OK|FAIL}

Save a message for a user who is currently not online.

### Get saved messages

    <sequence number> MSGGT <user name>
    [answer:]
    <sequence number> MSGS {OK <message 1> <message 2> <...>|FAIL}

Retrieve saved messages for a certain user. This operation SHALL fail if there is no user registered with the given name.
The messages itself MUST NOT contain newline characters.

The persistence implementation SHOULD delete the retrieved messages or mark them as delivered.

