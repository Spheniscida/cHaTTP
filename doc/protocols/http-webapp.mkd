# Webapp (incoming) protocol

This document describes how clients submit requests to a cHaTTP system via
HTTP (over FastCGI). It uses the keywords indicated by RFC 2119.

Requests MUST use the HTTP method `GET`, except for the "send message" request
which MUST use `POST`.

In general, non-ASCII characters are forbidden in user names and passwords. They are
transmitted in request URLs and we don't provide any logic yet to decode them.

## Paths

* Base path (`$base`): This is the path common to all other paths used by cHaTTP. It may be an arbitrary
path on the web server.
* Request path: The request path is `$base/chattp_request`.
* Poll path: The polling path is `$base/get`. It should be followed by a `?` character and a key value
pair with `chan_id` as the key and a ASCII string of usually 64 characters as value. Example:
`GET $base/get?chan_id=rtwmrsswunivdbhdybvaoswaaitrtdgyhldghevlttuyvykahkodmmxzyglkznea`. The web
server will not return a response until a new message has arrived.

## Sending requests

If HTTP POST is used, the Content-Type field MUST be set to `application/x-www-form-urlencoded`.
Additionally, the length of the request string MUST be specified in the `Content-Length` field.

If HTTP GET is used, the parameters have to be carried in the request string; e.g.: Parameter
`user`, value `john_doe`: `GET /foo/chattp?user_name=john_doe` etc. Several parameters are separated
by a `&` character.

If a request lacks parameters needed for an operation, it SHALL fail with HTTP status 400.

### Request types

#### Log-in

    GET $base/chattp_request/login?user_name=<user>&password=<password> HTTP/1.1

The `login` subcommand checks if the user is authorized to log-in and if he is, he marks
the user as online.

In the response, a channel id will be sent; this is the 64-character lower-case ASCII identifier
mentioned above. It serves the purpose of a cookie and identifies the user's session. It is used
to do long-polling as well as sending messages.

The server will respond to the login command with a JSON object containing the status (if the login
did succeed or not) and, if it did succeed, the channel id:

    HTTP/1.1 200 OK!
    Server: nginx/1.5.12
    Date: Tue, 22 Apr 2014 18:36:51 GMT
    Content-Type: text/plain
    Transfer-Encoding: chunked
    Connection: keep-alive

    {"type":"logged-in","status":true,"channel_id":"rtwmrsswunivdbhdybvaoswaaitrtdgyhldghevlttuyvykahkodmmxzyglkzneaa"}
    # or, if it failed:
    {"type":"logged-in","status":false,"channel_id":""}

#### Log-out

    GET $base/chattp_request/logout?user_name=<user>&channel_id=rtwmrsswunivdbhdybvaoswaaitrtdgyhldghevlttuyvykahkodmmxzyglkzneaa HTTP/1.1

Marks a user as offline (so new incoming messages are saved). This needs the channel id as authentication token
so not everyone may log out anyone else.

The reply is again in JSON, with a "type" field set to "logged-out" and a boolean "status" field.

#### Register a new user

    GET $base/chattp_request/register?user_name=<user>&password=<password>

Registers a user with the given user name and password.

The reply is a JSON object with a "type" field set to "registered", and a boolean "status" field, indicating if the operation succeeded or not. This operation
does not perform a log-in.

#### Send message

    POST $base/chattp_request/send?user_name=<user>&channel_id=rtwmrsswunivdbhdybvaoswaaitrtdgyhldghevlttuyvykahkodmmxzyglkzneaa&dest_user=<user2> HTTP/1.1
    Host: ...
    Content-Type: text/plain
    Content-Length: 13

    Hello, World!

This command is a little different in what HTTP methods are allowed to be used. POST must be used; the `user_name`, `channel_id` and `dest_user`
parameters are sent in the request string, the message is sent in the body. This avoids having the message encoded which
in turn allows any characters to be used in the message content. You may want to set the encoding in the HTTP headers appropriately.

The response will again contain a JSON object containing a boolean field "status" and a "type" field with the value "message-accepted".

#### Query status of user

    GET $base/chattp_request/isonline?user_name=<user>

Asks if the specified user is online. If he is, the JSON object in the reply body will have its "status" field set to `true`, else to `false`.
It is also set to `false` if the specified user doesn't exist. The "type" field is set to "isonline".

### Receiving messages


    GET $base/chattp_receive?chan_id=rtwmrsswunivdbhdybvaoswaaitrtdgyhldghevlttuyvykahkodmmxzyglkznea HTTP/1.1

As described, the `get` path with the `chan_id` parameter is used for waiting for a new message. Upon receiving the request,
the server will not return an answer until a new message has arrived.

The sender has to specify the timestamp of the last message received in the "If-Modified-Since" header field to receive
any message sent after. It is possible that the new request returns immediately with a message received by now:

    00:00:00 GET $base/get?chan_id=... HTTP/1.1
    00:00:10 HTTP/1.1 200 OK! ... Date: Sun, dd mmm yyyy 00:00:10 GMT ...
    00:00:10 ~display message~
    00:00:11 [new message arrives, but client hasn't polled yet]
    00:00:12 GET $base/get?chan_id=... HTTP/1.1 ... If-Modified-Since: Sun, dd mmm yyyy 00:00:10 GMT ...
    00:00:12 HTTP/1.1 200 OK! ... Date: Sun, dd mmm yyyy 00:00:11 GMT ...
    etc.

The received message is again encoded using JSON, with the following fields:

* "from" (string): Sender of the message.
* "message" (string): Actual message.

